{
    "abbrev": "format-tex-source",
    "description": [
        "Formats TeX source code by applying proper indentation, compressing multiple whitespace characters into one, etc."
    ],
    "formatVersion": 2,
    "menu": "",
    "name": "Format TeX source",
    "shortcut": "",
    "tag": [
        "// Configuration",
        "",
        "config = {",
        "\t// Names of environments that do not indent their children",
        "\tnoIndent: [],",
        "",
        "\t// Names of commands that should be placed on separate lines.",
        "\tseparateLine: ['\\\\documentclass', '\\\\usepackage'],",
        "",
        "\t// Line number after which hard wrap is performed by insertion of newline character(s).",
        "\t// Can be one of:",
        "\t//\t'autodetect': to autodetect the setting based on TeXstudio settings.",
        "\t//\t'none': to disable hard line wrapping. This will cause text nodes to be placed on a single line. Useful if TexStudio uses soft line wrapping.",
        "\t//\tany positive integer value (e.g. 80): to specify explicitly the line number after which the newline character(s) will be inserted.",
        "\t// Note that this value only affects text content that may be broken along whitespace. In some cases when there is no whitespace in the text content",
        "\t// a line may extend past the specified hard wrap column.",
        "\thardWrapColumn: 'autodetect'",
        "};",
        "",
        "// Common utility functions",
        "",
        "fatal_error = function (message) {",
        "\tthrow (message);",
        "};",
        "",
        "configArrayToMap = function (configArray) {",
        "\tvar result, i;",
        "",
        "\tresult = {};",
        "\tfor (i in configArray) {",
        "\t\tresult [configArray [i]] = null",
        "\t}",
        "\treturn (result);",
        "};",
        "",
        "// Class ParseNode. Represents one document node. Can be organized either in linear or tree form",
        "",
        "ParseNode = function (props) {",
        "\tvar i;",
        "",
        "\tfor (i in props) {",
        "\t\tthis [i] = props [i];",
        "\t}",
        "};",
        "ParseNode.prototype = {",
        "\taddChild: function (child) {",
        "\t\tif (('children' in this) == false) {",
        "\t\t\tfatal_error ('Cannot add a child to node of type: ' + this.type);",
        "\t\t}",
        "\t\tthis.children.push (child);",
        "\t}",
        "};",
        "// Each node type can be used in linear form, tree form or both",
        "ParseNode.typeComment = 1;\t// linear, tree",
        "ParseNode.typeEmptyLine = 2;\t// linear, tree",
        "ParseNode.typeEnv = 3;\t\t// tree",
        "ParseNode.typeEnvBegin = 4;\t// linear",
        "ParseNode.typeEnvEnd = 5;\t// linear",
        "ParseNode.typeRoot = 6;\t\t// tree",
        "ParseNode.typeText = 7;\t\t// linear, tree",
        "ParseNode.typeVerbatim = 8;\t// linear, tree",
        "ParseNode.createComment = function (text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeComment, text: text}));",
        "};",
        "ParseNode.createEmptyLine = function () {",
        "\treturn (new ParseNode ({type: ParseNode.typeEmptyLine}));",
        "};",
        "ParseNode.createEnv = function (envName, textOpen, textClose) {",
        "\treturn (new ParseNode ({",
        "\t\ttype: ParseNode.typeEnv,",
        "\t\tenvName: envName,",
        "\t\ttextOpen: textOpen,",
        "\t\ttextClose: textClose,",
        "\t\tchildren: []",
        "\t}));",
        "};",
        "ParseNode.createEnvBegin = function (envName, text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeEnvBegin, envName: envName, text: text}));",
        "};",
        "ParseNode.createEnvEnd = function (envName, text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeEnvEnd, envName: envName, text: text}));",
        "};",
        "ParseNode.createRoot = function () {",
        "\treturn (new ParseNode ({type: ParseNode.typeRoot, children: []}));",
        "};",
        "ParseNode.createText = function (text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeText, text: text}));",
        "};",
        "ParseNode.createVerbatim = function (text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeVerbatim, text: text}));",
        "};",
        "",
        "// Class ParseTree",
        "",
        "function ParseTree (document)",
        "{",
        "\tthis.tabNumCols = parseInt (ParseTree._priv_getSetting ('Editor/TabStop'));",
        "\tthis.tabString = ParseTree._priv_geTabString (this.tabNumCols);",
        "\tthis.hardWrapColumn = ParseTree._priv_getHardWrapColumn ();",
        "\tthis.eolString = document.lineEndingString ();",
        "\tthis._priv_parseDocument (document);",
        "}",
        "ParseTree.prototype = {",
        "\t_priv_parseDocument: function (document) {",
        "\t\tvar initial, linearNodes;",
        "",
        "\t\tinitial = ParseTree._priv_parseTxsTokensAndText (document);",
        "\t\tlinearNodes = ParseTree._priv_parseCombinedLinear (initial.tokens, initial.text);",
        "\t\tthis.root = ParseTree._priv_parseCombinedTree (linearNodes);",
        "\t},",
        "",
        "\tbuildText: function () {",
        "\t\tvar result;",
        "",
        "\t\tthis.indentNumPos = 0;",
        "\t\tthis.indentPrefix = '';",
        "\t\tresult = this._priv_buildNode (this.root);",
        "\t\tthis.indentPrefix = null;",
        "\t\tthis.indentNumPos = null;",
        "\t\treturn (result);",
        "\t},",
        "",
        "\t_priv_buildNode: function (node) {",
        "\t\tswitch (node.type) {",
        "\t\tcase ParseNode.typeComment:",
        "\t\tcase ParseNode.typeVerbatim:",
        "\t\t\treturn (this._priv_buildNodeVerbatim (node));",
        "\t\tcase ParseNode.typeEmptyLine:",
        "\t\t\treturn (this._priv_buildNodeEmptyLine ());",
        "\t\tcase ParseNode.typeEnv:",
        "\t\t\treturn (this._priv_buildNodeEnv (node));",
        "\t\tcase ParseNode.typeRoot:",
        "\t\t\treturn (this._priv_buildNodeRoot (node));",
        "\t\tcase ParseNode.typeText:",
        "\t\t\treturn (this._priv_buildNodeText (node));",
        "\t\tdefault:",
        "\t\t\tfatal_error ('Unsupported node type');",
        "\t\t}",
        "\t},",
        "",
        "\t_priv_buildNodeEmptyLine: function () {",
        "\t\treturn (this.eolString);",
        "\t},",
        "",
        "\t_priv_buildNodeEnv: function (node) {",
        "\t\tvar result, oldIndentNumPos, oldIndentPrefix;",
        "",
        "\t\tresult = this.indentPrefix + node.textOpen + this.eolString;",
        "\t\toldIndentNumPos = this.indentNumPos;",
        "\t\toldIndentPrefix = this.indentPrefix;",
        "\t\tif ((node.envName in config.noIndent) == false) {",
        "\t\t\tthis.indentNumPos += this.tabNumCols;",
        "\t\t\tthis.indentPrefix += this.tabString;",
        "\t\t}",
        "\t\tresult += this._priv_buildChildren (node);",
        "\t\tthis.indentNumPos = oldIndentNumPos;",
        "\t\tthis.indentPrefix = oldIndentPrefix;",
        "\t\tresult += this.indentPrefix + node.textClose + this.eolString;",
        "\t\treturn (result);",
        "\t},",
        "",
        "\t_priv_buildNodeRoot: function (node) {",
        "\t\treturn (this._priv_buildChildren (node));",
        "\t},",
        "",
        "\t_priv_buildNodeText: function (node) {",
        "\t\tvar getLineEnd = function (text, lineStart, maxLength) {",
        "\t\t\tvar maxPos, lineEnd, ch;",
        "",
        "\t\t\tmaxPos = lineStart + maxLength;",
        "\t\t\tif (maxPos >= text.length) {",
        "\t\t\t\treturn (text.length);",
        "\t\t\t}",
        "\t\t\t/*",
        "\t\t\t\tSearch for a line length that does not exceed the maximum allowed length.",
        "",
        "\t\t\t\tThe following code relies on the fact that text nodes have their leading and",
        "\t\t\t\ttrailing whitespace trimmed . Otherwise we could return an empty line string",
        "\t\t\t\twhich would cause an endless loop building the lines for the text node.",
        "\t\t\t*/",
        "\t\t\tfor (lineEnd = maxPos; lineEnd > lineStart; --lineEnd) {",
        "\t\t\t\t/*",
        "\t\t\t\t\tAll whitespace inside the text node has been compressed to single",
        "\t\t\t\t\tspace characters so as long as we found a space we know that the preceding",
        "\t\t\t\t\tcharacter is a non-whitespace character.",
        "\t\t\t\t*/",
        "\t\t\t\tif (text.charAt (lineEnd) == ' ') {",
        "\t\t\t\t\treturn (lineEnd);",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\t/*",
        "\t\t\t\tIt is not possible to get a line length that does not exceed the maximum",
        "\t\t\t\tallowed length. Try to find the minimal line length exceeding the maximum",
        "\t\t\t\tallowed length.",
        "\t\t\t*/",
        "\t\t\tfor (lineEnd = maxPos + 1; lineEnd < text.length; ++lineEnd) {",
        "\t\t\t\tif (text.charAt (lineEnd) == ' ') {",
        "\t\t\t\t\treturn (lineEnd);",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\t// The text does not contain any whitespace, so return the length of the whole text",
        "\t\t\treturn (text.length);",
        "\t\t};",
        "",
        "\t\tvar lineMaxLength, lineText, lineStart, lineEnd;",
        "",
        "\t\tif (this.hardWrapColumn === null) {",
        "\t\t\treturn (this.indentPrefix + node.text + this.eolString);",
        "\t\t}",
        "\t\tlineMaxLength =",
        "\t\t\t(this.indentNumPos < this.hardWrapColumn) ?",
        "\t\t\t(this.hardWrapColumn - this.indentNumPos) :",
        "\t\t\t0;",
        "\t\tlineText = '';",
        "\t\t/*",
        "\t\t\tAll whitespace inside the text node has been compressed to single",
        "\t\t\tspace characters so after processing each line we just add one to the current",
        "\t\t\tposition to get the start of the next line",
        "\t\t*/",
        "\t\tfor (lineStart = 0; lineStart < node.text.length; lineStart = lineEnd + 1) {",
        "\t\t\tlineEnd = getLineEnd (node.text, lineStart, lineMaxLength);",
        "\t\t\tlineText += this.indentPrefix + node.text.substring (lineStart, lineEnd) + this.eolString;",
        "\t\t}",
        "\t\treturn (lineText);",
        "\t},",
        "",
        "\t_priv_buildNodeVerbatim: function (node) {",
        "\t\treturn (this.indentPrefix + node.text + this.eolString);",
        "\t},",
        "",
        "\t_priv_buildChildren: function (node) {",
        "\t\tvar result, i, n;",
        "",
        "\t\tresult = '';",
        "\t\tfor (i = 0, n = node.children.length; i < n; ++i) {",
        "\t\t\tresult += this._priv_buildNode (node.children [i]);",
        "\t\t}",
        "\t\treturn (result);",
        "\t}",
        "};",
        "ParseTree._priv_geTabString = function (tabNumCols) {",
        "\tvar result, i;",
        "",
        "\tif (ParseTree._priv_getSetting ('Editor/Indent%20with%20Spaces') == 'true') {",
        "\t\tresult = '';",
        "\t\tfor (i = 0; i < tabNumCols; ++i) {",
        "\t\t\tresult += ' ';",
        "\t\t}",
        "\t} else {",
        "\t\tresult = \"\\t\";",
        "\t}",
        "\treturn (result);",
        "};",
        "ParseTree._priv_getHardWrapColumn = function () {",
        "\tif (config.hardWrapColumn === 'autodetect') {",
        "\t\treturn (",
        "\t\t\t(ParseTree._priv_getSetting ('Editor/WordWrapMode') === 3) ?",
        "\t\t\tParseTree._priv_getSetting ('Editor/WrapLineWidth') :",
        "\t\t\tnull",
        "\t\t);",
        "\t} else if (config.hardWrapColumn === 'none') {",
        "\t\treturn (null);",
        "\t} else if (ParseTree._priv_isInteger (config.hardWrapColumn) && (config.hardWrapColumn > 0)) {",
        "\t\treturn (config.hardWrapColumn);",
        "\t} else {",
        "\t\tfatal_error ('Bad value of config.hardWrapColumn');",
        "\t}",
        "};",
        "ParseTree._priv_isInteger = function (value) {",
        "\treturn (",
        "\t\t(isNaN (value) == false) &&",
        "\t\t(parseInt (value) === value)",
        "\t);",
        "};",
        "ParseTree._priv_getSetting = function (name) {",
        "\tvar value;",
        "",
        "\tif ((value = getPersistent (name)) === null) {",
        "\t\tfatal_error ('Missing setting \\'' + name + '\\' or access is denied');",
        "\t}",
        "\treturn (value);",
        "",
        "};",
        "ParseTree._priv_parseTxsTokensAndText = function (document) {",
        "\tvar documentTokens, documentText, lines, lineOffset, i, lineTokens, j, oneLineToken;",
        "",
        "\tdocumentTokens = [];",
        "\tdocumentText = '';",
        "\tlines = editor.document().textLines ();",
        "\t// When the last line ends with an EOL, TXS adds an extra empty line to the lines array",
        "\tif (lines.length && (lines [lines.length-1] == '')) {",
        "\t\tlines.pop ();",
        "\t}",
        "\tlineOffset = 0;",
        "\tfor (i = 0; i < lines.length; ++i) {",
        "\t\tif ((lineTokens = editor.getLineTokens (i)) === false) {",
        "\t\t\tfatal_error ('Line ' + i + ' does not have parse information');",
        "\t\t}",
        "\t\tfor (j = 0; j < lineTokens.length; ++j) {",
        "\t\t\toneLineToken = lineTokens [j];",
        "\t\t\tdocumentTokens.push ({",
        "\t\t\t\ttype: oneLineToken.type,",
        "\t\t\t\tsubtype: oneLineToken.subtype,",
        "\t\t\t\tlevel: oneLineToken.level,",
        "\t\t\t\toffset: lineOffset + oneLineToken.startColumn,",
        "\t\t\t\ttext: oneLineToken.text",
        "\t\t\t});",
        "\t\t}",
        "\t\tdocumentText += lines [i] + '\\n';",
        "\t\tlineOffset += lines [i].length + 1;",
        "\t}",
        "\treturn ({tokens: documentTokens, text: documentText});",
        "};",
        "ParseTree._priv_parseCombinedLinear = function (txsTokens, text) {",
        "\tvar linearNodes, textStart, txsIndex, oneTxsToken, commandInfo, envName, verbatimEnd;",
        "",
        "\tlinearNodes = [];",
        "\ttextStart = 0;",
        "\ttxsIndex = 0;",
        "\twhile (txsIndex < txsTokens.length) {",
        "\t\toneTxsToken = txsTokens [txsIndex];",
        "\t\tswitch (oneTxsToken.type) {",
        "\t\tcase latexTokenType.command:",
        "\t\t\tif (oneTxsToken.text in config.separateLine) {",
        "\t\t\t\tcommandInfo = ParseTree._priv_getCommandInfo (txsTokens, txsIndex);",
        "\t\t\t\tif (textStart < commandInfo.textStart) {",
        "\t\t\t\t\tParseTree._priv_parseCombinedText (linearNodes, text.substring (textStart, commandInfo.textStart));",
        "\t\t\t\t}",
        "\t\t\t\tlinearNodes.push (ParseNode.createText (text.substring (commandInfo.textStart, commandInfo.textEnd)));",
        "\t\t\t\ttextStart = commandInfo.textEnd;",
        "\t\t\t\ttxsIndex = commandInfo.nextTokenIndex;",
        "\t\t\t} else {",
        "\t\t\t\t++txsIndex;",
        "\t\t\t}",
        "\t\t\tbreak;",
        "\t\tcase latexTokenType.beginEnv:",
        "\t\t\tcommandInfo = ParseTree._priv_getCommandInfo (txsTokens, txsIndex);",
        "\t\t\tif (textStart < commandInfo.textStart) {",
        "\t\t\t\tParseTree._priv_parseCombinedText (linearNodes, text.substring (textStart, commandInfo.textStart));",
        "\t\t\t}",
        "\t\t\tenvName = oneTxsToken.text;",
        "\t\t\tif (envName == \"verbatim\") {",
        "\t\t\t\tverbatimEnd = ParseTree._priv_parseFindVerbatimEnd (txsTokens, txsIndex + 1);",
        "\t\t\t\tlinearNodes.push (ParseNode.createVerbatim (",
        "\t\t\t\t\ttext.substring (commandInfo.textStart, verbatimEnd.textEnd)",
        "\t\t\t\t))",
        "\t\t\t\ttextStart = verbatimEnd.textEnd;",
        "\t\t\t\ttxsIndex = verbatimEnd.nextTokenIndex;",
        "\t\t\t} else {",
        "\t\t\t\ttextStart = commandInfo.textEnd;",
        "\t\t\t\tlinearNodes.push (ParseNode.createEnvBegin (",
        "\t\t\t\t\tenvName,",
        "\t\t\t\t\ttext.substring (commandInfo.textStart, commandInfo.textEnd)",
        "\t\t\t\t))",
        "\t\t\t\ttxsIndex = commandInfo.nextTokenIndex;",
        "\t\t\t}",
        "\t\t\tbreak;",
        "\t\tcase latexTokenType.env:",
        "\t\t\tcommandInfo = ParseTree._priv_getCommandInfo (txsTokens, txsIndex);",
        "\t\t\tif (textStart < commandInfo.textStart) {",
        "\t\t\t\tParseTree._priv_parseCombinedText (linearNodes, text.substring (textStart, commandInfo.textStart));",
        "\t\t\t}",
        "\t\t\ttextStart = commandInfo.textEnd;",
        "\t\t\tlinearNodes.push (ParseNode.createEnvEnd (",
        "\t\t\t\ttxsTokens [txsIndex].text,",
        "\t\t\t\ttext.substring (commandInfo.textStart, commandInfo.textEnd)",
        "\t\t\t))",
        "\t\t\ttxsIndex = commandInfo.nextTokenIndex;",
        "\t\t\tbreak;",
        "\t\tdefault:",
        "\t\t\t++txsIndex;",
        "\t\t\tbreak;",
        "\t\t}",
        "\t}",
        "\tif (textStart < text.length) {",
        "\t\tParseTree._priv_parseCombinedText (linearNodes, text.substring (textStart));",
        "\t}",
        "\treturn (linearNodes);",
        "};",
        "ParseTree._priv_parseFindVerbatimEnd = function (txsTokens, startIndex) {",
        "\tvar index, oneTxsToken;",
        "",
        "\tfor (index = startIndex; index < txsTokens.length; ++index) {",
        "\t\toneTxsToken = txsTokens [index];",
        "\t\tif ((oneTxsToken.type == latexTokenType.env) && (oneTxsToken.text == \"verbatim\")) {",
        "\t\t\treturn (ParseTree._priv_getCommandInfo (txsTokens, index));",
        "\t\t}",
        "\t}",
        "\tfatal_error (\"Could not find \\\\end{verbatim}\");",
        "};",
        "ParseTree._priv_getCommandInfo = function (txsTokens, indexInner) {",
        "\tvar indexFirst, indexLast, textStart, textEnd, i, newStart, newEnd;",
        "",
        "\tindexFirst = ParseTree._priv_getCommandFirst (txsTokens, indexInner);",
        "\tindexLast = ParseTree._priv_getCommandLast (txsTokens, indexFirst);",
        "\t/*",
        "\t\tToken ends do not increase monotonically, e.g. \\begin{document}",
        "\t\tis represented by \\begin, {document}, document",
        "\t\tThat is why we have to check each token for leftmost/rightmost",
        "\t\tpostition in text.",
        "\t*/",
        "\ttextStart = null;",
        "\ttextEnd = null;",
        "\tfor (i = indexFirst; i <= indexLast; ++i) {",
        "\t\tnewStart = txsTokens [i].offset;",
        "\t\tnewEnd = newStart + txsTokens [i].text.length;",
        "\t\tif ((textStart === null) || (newStart < textStart)) {",
        "\t\t\ttextStart = newStart;",
        "\t\t}",
        "\t\tif ((textEnd === null) || (newEnd > textEnd)) {",
        "\t\t\ttextEnd = newEnd;",
        "\t\t}",
        "\t}",
        "\treturn ({",
        "\t\ttextStart: textStart,",
        "\t\ttextEnd: textEnd,",
        "\t\tnextTokenIndex: indexLast + 1",
        "\t});",
        "};",
        "ParseTree._priv_getCommandFirst = function (txsTokens, indexInner) {",
        "\tvar maxLevel, indexCmd, oneToken;",
        "",
        "\tmaxLevel = txsTokens [indexInner].level;",
        "\tfor (indexCmd = indexInner; indexCmd >= 0; --indexCmd) {",
        "\t\toneToken = txsTokens [indexCmd];",
        "\t\tif (",
        "\t\t\t(oneToken.level <= maxLevel) &&",
        "\t\t\t(oneToken.type == latexTokenType.command)",
        "\t\t) {",
        "\t\t\treturn (indexCmd);",
        "\t\t}",
        "\t\tif (maxLevel < oneToken.level) {",
        "\t\t\tmaxLevel = oneToken.level;",
        "\t\t}",
        "\t}",
        "\tfatal_error ('Could not find command for token ' + txsTokens [indexInner].text);",
        "};",
        "ParseTree._priv_getCommandLast = function (txsTokens, indexFirst) {",
        "\tvar commandLevel, indexLast;",
        "",
        "\tcommandLevel = txsTokens [indexFirst].level;",
        "\tfor (indexLast = indexFirst + 1; indexLast < txsTokens.length; ++indexLast) {",
        "\t\tif (txsTokens [indexLast].level <= commandLevel) {",
        "\t\t\tbreak;",
        "\t\t}",
        "\t}",
        "\t--indexLast;",
        "\treturn (indexLast);",
        "};",
        "ParseTree._priv_parseCombinedText = function (linearNodes, text) {",
        "\tvar tryCreateText = function (textStart, textEnd) {",
        "\t\tvar output;",
        "",
        "\t\tif (textStart == textEnd) {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\toutput = text.substring (textStart, textEnd);",
        "\t\toutput = output.replace (/\\s+/g, ' ');",
        "\t\toutput = output.trim ();",
        "\t\tif (output.length == 0) {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\tlinearNodes.push (ParseNode.createText (output));",
        "\t};",
        "",
        "\t/*",
        "\t\tThe TXS tokenizer does not provide the comment tokens (even though it has a comment token type),",
        "\t\tso we have to detect manually the comments. We also detect the empty lines (TeX paragraphs and",
        "\t\tturn them into typeEmptyLine nodes.",
        "\t*/",
        "\toffset = 0;",
        "\trx = /(\\n{2,})|%[^\\n]*/g;",
        "\trx.lastIndex = 0;",
        "\twhile ((match = rx.exec (text)) !== null) {",
        "\t\ttryCreateText (offset, match.index);",
        "\t\tswitch (match [0].charAt (0)) {",
        "\t\tcase '\\n':",
        "\t\t\tlinearNodes.push (ParseNode.createEmptyLine ());",
        "\t\t\tbreak;",
        "\t\tcase '%':",
        "\t\t\tlinearNodes.push (ParseNode.createComment (match [0]));",
        "\t\t\tbreak;",
        "\t\tdefault:",
        "\t\t\tfatal_error ('Unknown match type');",
        "\t\t}",
        "\t\toffset = match.index + match [0].length;",
        "\t}",
        "\ttryCreateText (offset, text.length);",
        "};",
        "ParseTree._priv_parseCombinedTree = function (linearNodes) {",
        "\tvar root;",
        "",
        "\troot = ParseNode.createRoot ();",
        "\tParseTree._priv_parseCombinedTreeChildren (root, linearNodes, 0, linearNodes.length);",
        "\treturn (root);",
        "};",
        "ParseTree._priv_parseCombinedTreeChildren = function (parent, linearNodes, indexBegin, indexEnd) {",
        "\tvar i, j, linearToken, treeToken;",
        "",
        "\ti = indexBegin;",
        "\twhile (i < indexEnd) {",
        "\t\tlinearToken = linearNodes [i];",
        "\t\tswitch (linearToken.type) {",
        "\t\tcase ParseNode.typeEnvBegin:",
        "\t\t\tj = ParseTree._priv_parseCombinedTreeFindEnvEnd (linearNodes, i, indexEnd);",
        "\t\t\ttreeToken = ParseNode.createEnv (linearToken.envName, linearToken.text, linearNodes [j].text);",
        "\t\t\tParseTree._priv_parseCombinedTreeChildren (treeToken, linearNodes, i+1, j);",
        "\t\t\tparent.addChild (treeToken);",
        "\t\t\ti = j + 1;",
        "\t\t\tbreak;",
        "\t\tcase ParseNode.typeEnvEnd:",
        "\t\t\tfatal_error ('Unexpected environment end');",
        "\t\tdefault:",
        "\t\t\tparent.addChild (linearToken);",
        "\t\t\t++i;",
        "\t\t\tbreak;",
        "\t\t}",
        "\t}",
        "};",
        "ParseTree._priv_parseCombinedTreeFindEnvEnd = function (linearNodes, indexBegin, indexLimit) {",
        "\tvar envName, depth, indexEnd, oneNode;",
        "",
        "\tenvName = linearNodes [indexBegin].envName;",
        "\tdepth = 1;",
        "\tfor (indexEnd = indexBegin + 1; indexEnd < indexLimit; ++indexEnd) {",
        "\t\toneNode = linearNodes [indexEnd];",
        "\t\tif ((oneNode.type == ParseNode.typeEnvBegin) && (oneNode.envName == envName)) {",
        "\t\t\t++depth;",
        "\t\t} else if ((oneNode.type == ParseNode.typeEnvEnd) && (oneNode.envName == envName)) {",
        "\t\t\tif (--depth == 0) {",
        "\t\t\t\treturn (indexEnd);",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\tfatal_error ('Could not find environment end');",
        "};",
        "",
        "// Global code",
        "",
        "config.noIndent = configArrayToMap (config.noIndent);",
        "config.separateLine = configArrayToMap (config.separateLine);",
        "if (typeof (editor) == 'undefined') {",
        "\tfatal_error ('No open editor');",
        "}",
        "tree = new ParseTree (editor.document ());",
        "newText = tree.buildText ();",
        "editor.setText (newText);",
        ""
    ],
    "trigger": ""
    "type": "Script"
}
